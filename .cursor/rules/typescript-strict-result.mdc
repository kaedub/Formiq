---
description: Strict TypeScript + result-first error modeling
globs: "**/*.ts,**/*.tsx"
alwaysApply: false
---

# TypeScript — Strict + Result-First

## Core mindset
- Write TypeScript that is explicit, extensible, and type-safe.
- Prefer fixing root causes upstream over adding downstream guards.
- New code is NOT sacred. If earlier code forces hacks, refactor it.

## Non-negotiables
- Do NOT use `any`. Use `unknown` at boundaries, then decode.
- Do NOT use non-null assertions (`!`).
- Do NOT use `// @ts-ignore`. If unavoidable, use `@ts-expect-error` with a clear explanation comment.
- Do NOT use type assertions (`as ...`) to silence errors. If unavoidable at a boundary, explain with `// SAFE:` and keep it localized.
- Do NOT add “magic strings” or placeholders to satisfy required fields.
- Do NOT use `??` or `||` to silence type errors. Defaults only when they are real business defaults and centralized.
- Do NOT introduce optional properties when the domain says they are required.

## Result-first error modeling
- Domain and application logic MUST NOT signal failure with `undefined`, `null`, sentinel values, empty strings, or empty arrays.
- If an operation can fail, return `Result<T, E>` (not `T | undefined`, not `T | null`).
- `undefined` is allowed ONLY for “parameter not provided” at API boundaries (DTOs). It must not exist in domain entities.
- `null` is disallowed in domain entities and return types unless explicitly required by an external API/DB shape. Convert at the boundary.

## Boundaries (validate once, then trust types)
- Treat external inputs as `unknown` (HTTP payloads, env vars, DB rows, files, queues).
- Decode/validate at boundaries into domain-safe types.
- Boundary layers should return `Result<DomainType, ParseError>` (or throw only at process-level entrypoints).
- Inside domain code, missing data is a bug: redesign types or return a typed error Result.

## Modeling (make illegal states unrepresentable)
- Prefer discriminated unions over booleans and ad-hoc flags.
- Prefer branded types for IDs and validated strings where useful (e.g. `UserId`, `Email`, `Url`, `NonEmptyString`).
- Use exhaustive checks for unions (`switch` + `assertNever`).
- Avoid “stringly-typed” states; centralize literals in `const` objects and use `as const` / `satisfies`.

## Required > optional
- If a value is required in reality, it must be required in the type.
- Optional fields must be justified with `// optional because ...` and should usually be confined to boundary DTOs.
- `Partial<T>` is allowed ONLY for patch/update DTOs at boundaries, never for domain entities.

## Defaults and fallbacks
- Defaults must be explicit and documented (e.g. config, constants). Do not hide defaults inside `??` or `||` at call sites.
